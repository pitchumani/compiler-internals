# GCC Compiler Overview
Retargettable compiler, accepts many high level languages and generates code for many different targets.

## Intermediate Representations (IR)
GCC's intermediate representations (IR) primarily consist of GENERIC, a high-level
tree-based IR, GIMPLE, a family of linearized tree IRs used for optimization, and
Register Transfer Language (RTL), a low-level, target-specific IR used to connect
the generic GCC framework to the specific machine backend.

GIMPLE itself has different forms, including high-level, low-level, and SSA (Static
Single Assignment) GIMPLE. You can dump these IR forms to examine them using compiler
flags like -fdump-tree-gimple.

You can inspect these IR forms using compiler flags:
-fdump-tree-gimple: Dumps the GIMPLE representation of the code.
-fdump-tree-cfg-raw: Dumps the Control Flow Graph (CFG) form of the GIMPLE code.

* AST - abstract syntax tree generated by parser
* GENERIC - Language independent tree like structure (gcc/tree.def)
* Gimple - three-address representation derived from GENERIC by breaking down the expressions
 into tuples of no more than three operands. Gimplifier is the pass which does the conversion.
  - High Gimple - Gimple that is not lowered fully
  - Low Gimple - Control structures are linearized
  - C/C++ frontends converts tree structures into Gimple directly (as per GCCInternals Ch11)
  - dump gimple IR using -fdump-tree-gimple option
  - Used for target independent optimizations (e.g. inlining, constant propagation, tail call elimination,
  redundancy elimination etc)
  - Uses SSA form
* RTL - low level IR Register Transfer Language, Close to machine code. The machine description files (.md)
define the pattern for each instruction that target machine supports.

### GENERIC:
* This is GCC's most abstract, high-level IR.
* It serves as a generic tree structure that all language front ends (like the C or C++
front ends) translate their code into.
* It represents the code's logical structure without machine-specific details.

### GIMPLE:
Developed from GENERIC, GIMPLE is a simpler, linear, tree-based IR.
It is the form of IR that the middle-end optimizer primarily works on.
There are three variations of GIMPLE:
* High-level GIMPLE: Produced when GENERIC is lowered, it still has complex control flow
structures.
* Low-level GIMPLE: Obtained by linearizing high-level GIMPLE, making it a flat
representation of control flow structures.
* SSA GIMPLE: Low-level GIMPLE rewritten into SSA form, which simplifies optimizations.

### RTL (Register Transfer Language):
This is a low-level, target-specific IR.
* RTL is used to connect the generic GCC framework to the specific machine backends,
which generate native code.
* It's also used for development to specify machine descriptions and for intraprocedural
passes.

## CFG
The control flow graph is a data structure that is built on top of IR representations(Gimple or RTL).
It is a directed graph, verties represent the basic blocks and the edges represent the possible control
flow from one basic block to another.
- *Basic Block: Straight line sequence of code that has one entry point and one exit point.*

## Static Single Assignment (SSA)
Static Single Assignment (SSA) is a compiler intermediate representation where each
variable is assigned a value only once, ensuring that every variable definition has
a single, unique assignment site in the program's static text. To achieve this, variables
are renamed into different versions (e.g., X becomes X1, X2) when they are assigned a new
value, especially in control flow paths. At merge points, like after an if-else statement,
phi functions are used to combine the different versions of a variable, returning the correct
value from whichever path was taken. SSA simplifies optimizations like dead code elimination
and constant folding by making variable uses clearly associated with a single definition.

### Key Characteristics
* Single Assignment: Each variable has exactly one definition site in the program's text.
* Renaming: When a variable is assigned a new value, it is renamed to a new version to
maintain the single-assignment property.
* Phi Functions: At control flow merge points (e.g., the end of a conditional statement),
phi functions are inserted to combine values from different paths into a single, new
version of the variable.

Example:
```C
// Source Code
a = 1;
if (x > 10) {
  a = 2;
} else {
  a = 3;
}
b = a + 1;
```
SSA representation
```C
a1 = 1;
if (x > 10) {
  a2 = 2;
} else {
  a3 = 3;
}
a4 = phi(a2, a3); // Chooses the correct 'a' based on the path
b1 = a4 + 1;
```

### Benefits
* Simplified Optimizations: Many compiler optimizations, such as dead code elimination,
constant folding, and redundancy elimination, become much simpler to implement because
each variable's definition is unique and known.
* Improved Data Flow Analysis: SSA form provides more available information at each
program point, improving the accuracy and effectiveness of data flow analysis.

### Challenges
* Increased Code Size: The renaming of variables and the insertion of phi functions
can increase the size of the intermediate representation.
* Conversion: Converting a non-SSA program into SSA form, and then translating it
back into non-SSA form for target code generation, can be a complex process.

## GIMPLE
GIMPLE is a three-address, language-independent intermediate representation used
within the GNU Compiler Collection (GCC) for optimization passes. It is derived
from GENERIC, another GCC internal representation, by simplifying expressions into
a more restrictive form.

### Key characteristics of GIMPLE:
* Three-address code: Most GIMPLE statements operate on a maximum of three operands,
simplifying analysis and transformation. Function calls are an exception to this rule.
* SSA-based: GIMPLE is typically in Static Single Assignment (SSA) form during
optimization, where each variable is assigned a value only once, facilitating
dataflow analysis.
* Control Flow Graph (CFG): GIMPLE statements are organized into Basic Blocks (BBs),
and the control flow between these blocks is represented by a CFG. Explicit control
flow structures like loops and if/else statements are lowered into GIMPLE_GOTO
statements and the CFG structure.
* Language-independent: GIMPLE can represent programs written in various languages
supported by GCC, serving as a common ground for optimizations.
* Two forms: High GIMPLE and Low GIMPLE:
  * High GIMPLE: Contains higher-level constructs like lexical scopes (GIMPLE_BIND)
and nested expressions, present before the pass_lower_cf pass.
  * Low GIMPLE: Explicitly represents all implicit jumps for control and exception
handling, making the control flow more direct.
* Used for target and language-independent optimizations: GIMPLE is the primary
representation for a wide range of optimizations, including inlining, constant
propagation, tail call elimination, and redundancy elimination.

Example of GIMPLE lowering:
A C conditional expression like a = b ? c : d; is lowered into GIMPLE as:
```
if (b)
  T1 = c;
else
  T1 = d;
a = T1;
```
Similarly, logical operators like a = b && c; are simplified:
```
T1 = (bool)b;
if (T1)
  T1 = (bool)c;
a = T1;
```

GIMPLE provides a structured and simplified representation of the program, enabling
efficient and effective optimization passes within the GCC compiler. You can inspect
the GIMPLE representation of your code using the -fdump-tree-gimple flag when
compiling with GCC.

## Register Transfer Language (RTL)
GCC's Register Transfer Language (RTL) is a low-level intermediate representation
used in the later stages of the compilation process. It describes instructions
in an algebraic form, inspired by Lisp lists, and serves as the foundation for
many optimizations and target-specific code generation.

### Key aspects of GCC's RTL representation:
* RTL Objects: RTL is built from various objects, including expressions, vectors,
strings, and integers.
* RTL Classes: These categorize RTL expression objects and define their structure,
determining the number and types of operands an expression should contain.
* Machine Modes: RTL uses machine modes to describe the size and format of data,
such as SImode for a 32-bit integer or DFmode for a double-precision floating-point
number.
* Expressions: The core of RTL, expressions represent various operations and data.
Examples include:
  * Constants: const_int, const_double
  * Registers and Memory: reg, mem
  * Arithmetic: plus, minus, mult, div
  * Comparisons: eq, ne, lt, gt
  * Side Effects: set (for storing values), call (for function calls)
* Insn (Instruction) Expressions: Specific expression types represent entire
instructions, allowing the compiler to model the target machine's instruction set.
* Textual Form: RTL has a textual representation used in machine descriptions
and debugging dumps, employing nested parentheses to represent the structure of
expressions, similar to Lisp. For example:
```Lisp
    (set (reg:SI 0) (plus:SI (reg:SI 0) (const_int 1)))
```
This represents an instruction that adds 1 to the value in register 0 and stores
the result back in register 0.

* Internal Form: Internally, RTL is represented by C structures that point to other
structures, forming a tree-like data structure.
* RTL SSA Form: For certain optimizations, GCC can transform RTL into Static Single
Assignment (SSA) form, providing information about the definitions and uses of
register values.

RTL's design allows for flexible and efficient manipulation during optimization
passes and facilitates the generation of machine-specific assembly code by providing
a detailed and structured representation of the program's operations.
